<%- param_name_plural = table_name = @model_name.underscore.pluralize -%>
<%- model_name_underscore = @model_name.underscore -%>
<%- col_names = @struct_info[:col_names] -%>
// The file is generated by go-on-rails, a Rails generator gem:
// https://rubygems.org/gems/go-on-rails
// Or on Github: https://github.com/goonr/go-on-rails
// By B1nj0y <idegorepl@gmail.com>
package model

import (
	"errors"
	"fmt"
	"log"
	"strings"
	<%- if @struct_info[:has_datetime_type] -%>
	"time"
    <%- end -%>
)

type <%= @model_name %> struct {
	<%= @struct_info[:struct_body] -%>
}

// Find<%= @model_name %> find a single <%= model_name_underscore %> by an id
func Find<%= @model_name %>(id int64) (*<%= @model_name %>, error) {
	if id == 0 {
		return nil, errors.New("Invalid id: it can't be zero")
	}
	var_<%= model_name_underscore %> := <%= @model_name %>{}
	err := db.Get(&var_<%= model_name_underscore %>, "SELECT * FROM <%= table_name %> WHERE id = $1 LIMIT 1", id)
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return &var_<%= model_name_underscore %>, nil
}

// Find<%= @model_name.pluralize %> find one or more <%= model_name_underscore.pluralize %> by one or more ids
func Find<%= @model_name.pluralize %>(ids ...int64) ([]<%= @model_name %>, error) {
	if len(ids) == 0 {
		msg := "At least one or more ids needed"
		log.Println(msg)
		return nil, errors.New(msg)
	}
	var_<%= param_name_plural %> := []<%= @model_name %>{}
	idsStr := strings.Trim(strings.Replace(fmt.Sprint(ids), " ", ",", -1), "[]")
	sql := fmt.Sprintf(`SELECT * FROM <%= table_name %> WHERE id IN (%s)`, idsStr)
	err := db.Select(&var_<%= param_name_plural %>, sql)
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return var_<%= param_name_plural %>, nil
}

// Find<%= @model_name %>By find a single <%= model_name_underscore %> by a field name and a value
func Find<%= @model_name %>By(field string, val interface{}) (*<%= @model_name %>, error) {
	var_<%= model_name_underscore %> := <%= @model_name %>{}
	sqlFmt := `SELECT * FROM <%= table_name %> WHERE %s = $1 LIMIT 1`
	sqlStr := fmt.Sprintf(sqlFmt, field)
	err := db.Get(&var_<%= model_name_underscore %>, sqlStr, val)
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return &var_<%= model_name_underscore %>, nil
}

// Find<%= @model_name.pluralize %>By find all <%= param_name_plural %> by a field name and a value
func Find<%= @model_name.pluralize %>By(field string, val interface{}) (var_<%= param_name_plural %> []<%= @model_name %>, err error) {
	sqlFmt := `SELECT * FROM <%= table_name %> WHERE %s = $1`
	sqlStr := fmt.Sprintf(sqlFmt, field)
	err = db.Select(&var_<%= param_name_plural %>, sqlStr, val)
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return var_<%= param_name_plural %>, nil
}

// All<%= @model_name.pluralize %> get all the <%= @model_name %> records
func All<%= @model_name.pluralize %>() (<%= param_name_plural %> []<%= @model_name %>, err error) {
	err = db.Select(&<%= table_name %>, "SELECT * FROM <%= table_name %>")
	if err != nil {
		log.Print(err)
		return nil, err
	}
	return <%= param_name_plural %>, nil
}

// <%= @model_name %>Ids get all the Ids of <%= @model_name %> records
func <%= @model_name %>Ids() (ids []int64, err error) {
	err = db.Select(&ids, "SELECT id FROM <%= table_name %>")
	if err != nil {
		log.Print(err)
		return nil, err
	}
	return ids, nil
}

// <%= @model_name %>Ids get all the Ids of <%= @model_name %> records by where restriction
func <%= @model_name %>IdsWhere(where string, args ...interface{}) ([]int64, error) {
	ids, err := <%= @model_name %>IntCol("id", where, args...)
	return ids, err
}

// <%= @model_name %>IntCol get some int64 typed column of <%= @model_name %> by where restriction
func <%= @model_name %>IntCol(col, where string, args ...interface{}) (intColRecs []int64, err error) {
	sql := "SELECT " + col + " FROM <%= table_name %>"
	if len(where) > 0 {
		sql = sql + " WHERE " + where
	}
	stmt, err := db.Preparex(sql)
	if err != nil {
		log.Print(err)
		return nil, err
	}
	err = stmt.Select(&intColRecs, args...)
	if err != nil {
		log.Print(err)
		return nil, err
	}
	return intColRecs, nil
}

// <%= @model_name %>StrCol get some string typed column of <%= @model_name %> by where restriction
func <%= @model_name %>StrCol(col, where string, args ...interface{}) (strColRecs []string, err error) {
	sql := "SELECT " + col + " FROM <%= table_name %>"
	if len(where) > 0 {
		sql = sql + " WHERE " + where
	}
	stmt, err := db.Preparex(sql)
	if err != nil {
		log.Print(err)
		return nil, err
	}
	err = stmt.Select(&strColRecs, args...)
	if err != nil {
		log.Print(err)
		return nil, err
	}
	return strColRecs, nil
}

// Find<%= @model_name.pluralize %>Where query use a partial SQL clause that usually following after WHERE
// with placeholders, eg: FindUsersWhere("first_name = ? AND age > ?", "John", 18)
// will return those records in the table "users" whose first_name is "John" and age elder than 18
func Find<%= @model_name.pluralize %>Where(where string, args ...interface{}) (<%= param_name_plural %> []<%= @model_name %>, err error) {
	sql := "SELECT * FROM <%= table_name %>"
	if len(where) > 0 {
		sql = sql + " WHERE " + where
	}
	stmt, err := db.Preparex(sql)
	if err != nil {
		log.Print(err)
		return nil, err
	}
	err = stmt.Select(&<%= param_name_plural %>, args...)
	if err != nil {
		log.Print(err)
		return nil, err
	}
	return <%= param_name_plural %>, nil
}

// Find<%= @model_name.pluralize %>BySql query use a complete SQL clause
// with placeholders, eg: FindUsersBySql("SELECT * FROM users WHERE first_name = ? AND age > ?", "John", 18)
// will return those records in the table "users" whose first_name is "John" and age elder than 18
func Find<%= @model_name.pluralize %>BySql(sql string, args ...interface{}) (<%= param_name_plural %> []<%= @model_name %>, err error) {
	stmt, err := db.Preparex(sql)
	if err != nil {
		log.Print(err)
		return nil, err
	}
	err = stmt.Select(&<%= param_name_plural %>, args...)
	if err != nil {
		log.Print(err)
		return nil, err
	}
	return <%= param_name_plural %>, nil
}

func Create<%= @model_name %>(am map[string]interface{}) error {
	if len(am) == 0 {
		return fmt.Errorf("Zero key in the attributes map!")
	}
<%- unless @struct_info[:timestamp_cols].empty? -%>
	t := time.Now()
	for _, v := range []string{<%= @struct_info[:timestamp_cols].map(&:inspect).join(", ") %>} {
		if am[v] == nil {
			am[v] = t
		}
	}
<%- end -%>
	keys := make([]string, len(am))
	i := 0
	for k := range am {
		keys[i] = k
		i++
	}
	sqlFmt := `INSERT INTO <%= table_name %> (%s) VALUES (%s)`
	sqlStr := fmt.Sprintf(sqlFmt, strings.Join(keys, ","), ":"+strings.Join(keys, ",:"))
	_, err := db.NamedExec(sqlStr, am)
	if err != nil {
		log.Print(err)
		return err
	}
	return nil
}

func (var_<%= model_name_underscore %> *<%= @model_name %>) Create() error {
<%- unless @struct_info[:timestamp_cols].empty? -%>
	t := time.Now()
	<%- @struct_info[:timestamp_cols].each do |c| -%>
	var_<%= model_name_underscore %>.<%= c.camelize %> = t
    <%- end -%>
<%- end -%>
    sql := `INSERT INTO <%= table_name %> (<%= col_names.join(",") %>) VALUES (:<%= col_names.join(",:") %>)`
    _, err := db.NamedExec(sql, var_<%= model_name_underscore %>)
    return err
}

<%- unless @struct_info[:assoc_info][:has_many].empty? -%>
	<%- has_many = @struct_info[:assoc_info][:has_many] -%>
	<%- has_many.each do |k, v| -%>
func (var_<%= model_name_underscore %> *<%= @model_name %>) <%= v[:class_name].pluralize %>Create(am map[string]interface{}) error {
	<%- if v[:foreign_key] -%>
	am["<%= v[:foreign_key] %>"] = var_<%= model_name_underscore %>.Id
    <%- else -%>
	am["<%= model_name_underscore %>_id"] = var_<%= model_name_underscore %>.Id
	<%- end -%>
	err := Create<%= v[:class_name] %>(am)
	return err
}

func (var_<%= model_name_underscore %> *<%= @model_name %>) Get<%= v[:class_name].pluralize %>() error {
	<%- if v[:foreign_key] -%>
	var_<%= v[:class_name].underscore.pluralize %>, err := Find<%= v[:class_name].pluralize %>By("<%= v[:foreign_key] %>", var_<%= model_name_underscore %>.Id)
    <%- else -%>
	var_<%= v[:class_name].underscore.pluralize %>, err := Find<%= v[:class_name].pluralize %>By("<%= model_name_underscore %>_id", var_<%= model_name_underscore %>.Id)
	<%- end -%>
	if err == nil {
		var_<%= model_name_underscore %>.<%= k %> = var_<%= v[:class_name].underscore.pluralize %>
	}
	return err
}
	<%- end -%>
<%- end -%>

<%- unless @struct_info[:assoc_info][:has_one].empty? -%>
	<%- has_one = @struct_info[:assoc_info][:has_one] -%>
	<%- has_one.each do |k, v| -%>
func (var_<%= model_name_underscore %> *<%= @model_name %>) Create<%= v[:class_name] %>(am map[string]interface{}) error {
	<%- if v[:foreign_key] -%>
	am["<%= v[:foreign_key] %>"] = var_<%= model_name_underscore %>.Id
    <%- else -%>
	am["<%= model_name_underscore %>_id"] = var_<%= model_name_underscore %>.Id
	<%- end -%>
	err := Create<%= v[:class_name] %>(am)
	return err
}
	<%- end -%>
<%- end -%>

<%- unless @struct_info[:assoc_info][:belongs_to].empty? -%>
	<%- belongs_to = @struct_info[:assoc_info][:belongs_to] -%>
	<%- belongs_to.each do |k, v| -%>
func (var_<%= model_name_underscore %> *<%= @model_name %>) Create<%= v[:class_name] %>(am map[string]interface{}) error {
	<%- if v[:foreign_key] -%>
	am["<%= v[:foreign_key] %>"] = var_<%= model_name_underscore %>.Id
    <%- else -%>
	am["<%= model_name_underscore %>_id"] = var_<%= model_name_underscore %>.Id
	<%- end -%>
	err := Create<%= v[:class_name] %>(am)
	return err
}
	<%- end -%>
<%- end -%>

func (var_<%= model_name_underscore %> *<%= @model_name %>) Destroy() error {
	if var_<%= model_name_underscore %>.Id == 0 {
		return errors.New("Invalid Id field: it can't be a zero value")
	}
	err := Destroy<%= @model_name %>(var_<%= model_name_underscore %>.Id)
	return err
}

func Destroy<%= @model_name %>(id int64) error {
	stmt, err := db.Preparex(`DELETE FROM <%= table_name %> WHERE id = ?`)
	_, err = stmt.Exec(id)
	if err != nil {
		return err
	}
	<%- [:has_many, :has_one].each do |ass| -%>
		<%- ass_cols = @struct_info[:assoc_info][ass] -%>
		<%- unless ass_cols.empty? -%>
			<%- ass_cols.each_value do |opts| -%>
				<%- if opts.key? :dependent -%>
					<%- if opts.key? :foreign_key -%>
    Destroy<%= opts[:class_name].pluralize %>Where("<%= opts[:foreign_key] %> = ?", id)
					<%- else -%>
    Destroy<%= opts[:class_name].pluralize %>Where("<%= model_name_underscore %>_id = ?", id)
					<%- end -%>
				<%- end -%>
			<%- end -%>
		<%- end -%>
	<%- end -%>
	return nil
}

func Destroy<%= @model_name.pluralize %>(ids ...int64) (int64, error) {
	if len(ids) == 0 {
		msg := "At least one or more ids needed"
		log.Println(msg)
		return 0, errors.New(msg)
	}
	idsStr := strings.Trim(strings.Replace(fmt.Sprint(ids), " ", ",", -1), "[]")
	sql := fmt.Sprintf(`DELETE FROM <%= table_name %> WHERE id IN (%s)`, idsStr)
	stmt, err := db.Preparex(sql)
	result, err := stmt.Exec()
	if err != nil {
		return 0, err
	}
	cnt, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	<%- [:has_many, :has_one].each do |ass| -%>
		<%- ass_cols = @struct_info[:assoc_info][ass] -%>
		<%- unless ass_cols.empty? -%>
			<%- ass_cols.each_value do |opts| -%>
				<%- if opts.key? :dependent -%>
					<%- if opts.key? :foreign_key -%>
    where := fmt.Sprintf("<%= opts[:foreign_key] %> IN (%s)", idsStr)
    Destroy<%= opts[:class_name].pluralize %>Where(where)
					<%- else -%>
	where := fmt.Sprintf("<%= model_name_underscore %>_id IN (%s)", idsStr)
    Destroy<%= opts[:class_name].pluralize %>Where(where)
					<%- end -%>
				<%- end -%>
			<%- end -%>
		<%- end -%>
	<%- end -%>
	return cnt, nil
}

// Destroy<%= @model_name.pluralize %>Where delete records by a where clause
// like: Destroy<%= @model_name.pluralize %>Where("name = ?", "John")
// And this func will not call the association dependent action
func Destroy<%= @model_name.pluralize %>Where(where string, args ...interface{}) (int64, error) {
	sql := `DELETE FROM <%= table_name %> WHERE `
	if len(where) > 0 {
		sql = sql + where
	} else {
		return 0, errors.New("No WHERE conditions provided")
	}
	stmt, err := db.Preparex(sql)
	result, err := stmt.Exec(args...)
	if err != nil {
		return 0, err
	}
	cnt, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	return cnt, nil
}

func (var_<%= model_name_underscore %> *<%= @model_name %>) Save() error {
	if var_<%= model_name_underscore %>.Id == 0 {
		return errors.New("Invalid Id field: it can't be a zero value")
	}
<%- if @struct_info[:timestamp_cols].include? "updated_at" -%>
	var_<%= model_name_underscore %>.UpdatedAt = time.Now()
<%- end -%>
	sqlFmt := `UPDATE <%= table_name %> SET %s WHERE id = %v`
	sqlStr := fmt.Sprintf(sqlFmt, "<%= col_names.zip(col_names).map{|c| c.join(" = :")}.join(", ") %>", var_<%= model_name_underscore %>.Id)
    _, err := db.NamedExec(sqlStr, var_<%= model_name_underscore %>)
    return err
}

func Update<%= @model_name %>(id int64, am map[string]interface{}) error {
	if len(am) == 0 {
		return errors.New("Zero key in the attributes map!")
	}
<%- if @struct_info[:timestamp_cols].include? "updated_at" -%>
	am["updated_at"] = time.Now()
<%- end -%>
	keys := make([]string, len(am))
	i := 0
	for k := range am {
		keys[i] = k
		i++
	}
	sqlFmt := `UPDATE <%= table_name %> SET %s WHERE id = %v`
	setKeysArr := []string{}
	for _,v := range keys {
		s := fmt.Sprintf(" %s = :%s", v, v)
		setKeysArr = append(setKeysArr, s)
	}
	sqlStr := fmt.Sprintf(sqlFmt, strings.Join(setKeysArr, ", "), id)
	_, err := db.NamedExec(sqlStr, am)
	if err != nil {
		log.Print(err)
		return err
	}
	return nil
}

func (var_<%= model_name_underscore %> *<%= @model_name %>) Update(am map[string]interface{}) error {
	if var_<%= model_name_underscore %>.Id == 0 {
		return errors.New("Invalid Id field: it can't be a zero value")
	}
	err := Update<%= @model_name %>(var_<%= model_name_underscore %>.Id, am)
	return err
}

func (var_<%= model_name_underscore %> *<%= @model_name %>) UpdateAttributes(am map[string]interface{}) error {
	if var_<%= model_name_underscore %>.Id == 0 {
		return errors.New("Invalid Id field: it can't be a zero value")
	}
	err := Update<%= @model_name %>(var_<%= model_name_underscore %>.Id, am)
	return err
}

func (var_<%= model_name_underscore %> *<%= @model_name %>) UpdateColumns(am map[string]interface{}) error {
	if var_<%= model_name_underscore %>.Id == 0 {
		return errors.New("Invalid Id field: it can't be a zero value")
	}
	err := Update<%= @model_name %>(var_<%= model_name_underscore %>.Id, am)
	return err
}

func Update<%= @model_name.pluralize %>BySql(sql string, args ...interface{}) (int64, error) {
	if sql == "" {
		return 0, errors.New("A blank SQL clause")
	}
<%- if @struct_info[:timestamp_cols].include? "updated_at" -%>
	sql = strings.Replace(strings.ToLower(sql), "set", "set updated_at = ?, ", 1)
	args = append([]interface{}{time.Now()}, args...)
<%- end -%>
	stmt, err := db.Preparex(sql)
	result, err := stmt.Exec(args...)
	if err != nil {
		return 0, err
	}
	cnt, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	return cnt, nil
}
