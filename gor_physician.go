// The file is generated by go-on-rails, a Rails generator gem:
// https://rubygems.org/gems/go-on-rails
// Or on Github: https://github.com/goonr/go-on-rails
// By B1nj0y <idegorepl@gmail.com>
package model

import (
	"errors"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/asaskevich/govalidator"
)

type Physician struct {
	Id           int64         `json:"id,omitempty" db:"id" valid:"-"`
	Name         string        `json:"name,omitempty" db:"name" valid:"required,length(6|15)"`
	CreatedAt    time.Time     `json:"created_at,omitempty" db:"created_at" valid:"-"`
	UpdatedAt    time.Time     `json:"updated_at,omitempty" db:"updated_at" valid:"-"`
	Introduction string        `json:"introduction,omitempty" db:"introduction" valid:"required"`
	Appointments []Appointment `json:"appointments,omitempty" db:"appointments" valid:"-"`
	Patients     []Patient     `json:"patients,omitempty" db:"patients" valid:"-"`
	Pictures     []Picture     `json:"pictures,omitempty" db:"pictures" valid:"-"`
}

// FindPhysician find a single physician by an id
func FindPhysician(id int64) (*Physician, error) {
	if id == 0 {
		return nil, errors.New("Invalid id: it can't be zero")
	}
	var_physician := Physician{}
	err := db.Get(&var_physician, db.Rebind(`SELECT * FROM physicians WHERE id = ? LIMIT 1`), id)
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return &var_physician, nil
}

// FirstPhysician find the first one physician by id ASC order
func FirstPhysician() (*Physician, error) {
	var_physician := Physician{}
	err := db.Get(&var_physician, db.Rebind(`SELECT * FROM physicians ORDER BY id ASC LIMIT 1`))
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return &var_physician, nil
}

// FirstPhysicians find the first N physicians by id ASC order
func FirstPhysicians(n uint32) ([]Physician, error) {
	var_physicians := []Physician{}
	sql := fmt.Sprintf("SELECT * FROM physicians ORDER BY id ASC LIMIT %v", n)
	err := db.Select(&var_physicians, db.Rebind(sql))
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return var_physicians, nil
}

// LastPhysician find the last one physician by id DESC order
func LastPhysician() (*Physician, error) {
	var_physician := Physician{}
	err := db.Get(&var_physician, db.Rebind(`SELECT * FROM physicians ORDER BY id DESC LIMIT 1`))
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return &var_physician, nil
}

// LastPhysicians find the last N physicians by id DESC order
func LastPhysicians(n uint32) ([]Physician, error) {
	var_physicians := []Physician{}
	sql := fmt.Sprintf("SELECT * FROM physicians ORDER BY id DESC LIMIT %v", n)
	err := db.Select(&var_physicians, db.Rebind(sql))
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return var_physicians, nil
}

// FindPhysicians find one or more physicians by one or more ids
func FindPhysicians(ids ...int64) ([]Physician, error) {
	if len(ids) == 0 {
		msg := "At least one or more ids needed"
		log.Println(msg)
		return nil, errors.New(msg)
	}
	var_physicians := []Physician{}
	idsHolder := strings.Repeat(",?", len(ids)-1)
	sql := db.Rebind(fmt.Sprintf(`SELECT * FROM physicians WHERE id IN (?%s)`, idsHolder))
	idsT := []interface{}{}
	for _, id := range ids {
		idsT = append(idsT, interface{}(id))
	}
	err := db.Select(&var_physicians, sql, idsT...)
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return var_physicians, nil
}

// FindPhysicianBy find a single physician by a field name and a value
func FindPhysicianBy(field string, val interface{}) (*Physician, error) {
	var_physician := Physician{}
	sqlFmt := `SELECT * FROM physicians WHERE %s = ? LIMIT 1`
	sqlStr := fmt.Sprintf(sqlFmt, field)
	err := db.Get(&var_physician, db.Rebind(sqlStr), val)
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return &var_physician, nil
}

// FindPhysiciansBy find all physicians by a field name and a value
func FindPhysiciansBy(field string, val interface{}) (var_physicians []Physician, err error) {
	sqlFmt := `SELECT * FROM physicians WHERE %s = ?`
	sqlStr := fmt.Sprintf(sqlFmt, field)
	err = db.Select(&var_physicians, db.Rebind(sqlStr), val)
	if err != nil {
		log.Printf("Error: %v\n", err)
		return nil, err
	}
	return var_physicians, nil
}

// AllPhysicians get all the Physician records
func AllPhysicians() (physicians []Physician, err error) {
	err = db.Select(&physicians, "SELECT * FROM physicians")
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return physicians, nil
}

// PhysicianCount get the count of all the Physician records
func PhysicianCount() (c int64, err error) {
	err = db.Get(&c, "SELECT count(*) FROM physicians")
	if err != nil {
		log.Println(err)
		return 0, err
	}
	return c, nil
}

// PhysicianCountWhere get the count of all the Physician records with a where clause
func PhysicianCountWhere(where string, args ...interface{}) (c int64, err error) {
	sql := "SELECT count(*) FROM physicians"
	if len(where) > 0 {
		sql = sql + " WHERE " + where
	}
	stmt, err := db.Preparex(db.Rebind(sql))
	if err != nil {
		log.Println(err)
		return 0, err
	}
	err = stmt.Get(&c, args...)
	if err != nil {
		log.Println(err)
		return 0, err
	}
	return c, nil
}

// PhysicianIncludesWhere get the Physician associated models records, it's just the eager_load function
func PhysicianIncludesWhere(assocs []string, sql string, args ...interface{}) (var_physicians []Physician, err error) {
	var_physicians, err = FindPhysiciansWhere(sql, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	if len(assocs) == 0 {
		log.Println("No associated fields ard specified")
		return var_physicians, err
	}
	if len(var_physicians) <= 0 {
		return nil, errors.New("No results available")
	}
	ids := make([]interface{}, len(var_physicians))
	for _, v := range var_physicians {
		ids = append(ids, interface{}(v.Id))
	}
	idsHolder := strings.Repeat(",?", len(ids)-1)
	for _, assoc := range assocs {
		switch assoc {
		case "appointments":
			where := fmt.Sprintf("physician_id IN (?%s)", idsHolder)
			var_appointments, err := FindAppointmentsWhere(where, ids...)
			if err != nil {
				log.Printf("Error when query associated objects: %v\n", assoc)
				continue
			}
			for _, vv := range var_appointments {
				for i, vvv := range var_physicians {
					if vv.PhysicianId == vvv.Id {
						vvv.Appointments = append(vvv.Appointments, vv)
					}
					var_physicians[i].Appointments = vvv.Appointments
				}
			}
		case "patients":
			// FIXME: optimize the query
			for i, vvv := range var_physicians {
				var_patients, err := PhysicianGetPatients(vvv.Id)
				if err != nil {
					continue
				}
				vvv.Patients = var_patients
				var_physicians[i] = vvv
			}
		case "pictures":
			// FIXME: optimize the query
			for i, vvv := range var_physicians {
				var_pictures, err := PhysicianGetPictures(vvv.Id)
				if err != nil {
					continue
				}
				vvv.Pictures = var_pictures
				var_physicians[i] = vvv
			}
		}
	}
	return var_physicians, nil
}

// PhysicianIds get all the Ids of Physician records
func PhysicianIds() (ids []int64, err error) {
	err = db.Select(&ids, "SELECT id FROM physicians")
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return ids, nil
}

// PhysicianIds get all the Ids of Physician records by where restriction
func PhysicianIdsWhere(where string, args ...interface{}) ([]int64, error) {
	ids, err := PhysicianIntCol("id", where, args...)
	return ids, err
}

// PhysicianIntCol get some int64 typed column of Physician by where restriction
func PhysicianIntCol(col, where string, args ...interface{}) (intColRecs []int64, err error) {
	sql := "SELECT " + col + " FROM physicians"
	if len(where) > 0 {
		sql = sql + " WHERE " + where
	}
	stmt, err := db.Preparex(db.Rebind(sql))
	if err != nil {
		log.Println(err)
		return nil, err
	}
	err = stmt.Select(&intColRecs, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return intColRecs, nil
}

// PhysicianStrCol get some string typed column of Physician by where restriction
func PhysicianStrCol(col, where string, args ...interface{}) (strColRecs []string, err error) {
	sql := "SELECT " + col + " FROM physicians"
	if len(where) > 0 {
		sql = sql + " WHERE " + where
	}
	stmt, err := db.Preparex(db.Rebind(sql))
	if err != nil {
		log.Println(err)
		return nil, err
	}
	err = stmt.Select(&strColRecs, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return strColRecs, nil
}

// FindPhysiciansWhere query use a partial SQL clause that usually following after WHERE
// with placeholders, eg: FindUsersWhere("first_name = ? AND age > ?", "John", 18)
// will return those records in the table "users" whose first_name is "John" and age elder than 18
func FindPhysiciansWhere(where string, args ...interface{}) (physicians []Physician, err error) {
	sql := "SELECT * FROM physicians"
	if len(where) > 0 {
		sql = sql + " WHERE " + where
	}
	stmt, err := db.Preparex(db.Rebind(sql))
	if err != nil {
		log.Println(err)
		return nil, err
	}
	err = stmt.Select(&physicians, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return physicians, nil
}

// FindPhysiciansBySql query use a complete SQL clause
// with placeholders, eg: FindUsersBySql("SELECT * FROM users WHERE first_name = ? AND age > ?", "John", 18)
// will return those records in the table "users" whose first_name is "John" and age elder than 18
func FindPhysiciansBySql(sql string, args ...interface{}) (physicians []Physician, err error) {
	stmt, err := db.Preparex(db.Rebind(sql))
	if err != nil {
		log.Println(err)
		return nil, err
	}
	err = stmt.Select(&physicians, args...)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return physicians, nil
}

func CreatePhysician(am map[string]interface{}) (int64, error) {
	if len(am) == 0 {
		return 0, fmt.Errorf("Zero key in the attributes map!")
	}
	t := time.Now()
	for _, v := range []string{"created_at", "updated_at"} {
		if am[v] == nil {
			am[v] = t
		}
	}
	keys := make([]string, len(am))
	i := 0
	for k := range am {
		keys[i] = k
		i++
	}
	sqlFmt := `INSERT INTO physicians (%s) VALUES (%s)`
	sqlStr := fmt.Sprintf(sqlFmt, strings.Join(keys, ","), ":"+strings.Join(keys, ",:"))
	result, err := db.NamedExec(sqlStr, am)
	if err != nil {
		log.Println(err)
		return 0, err
	}
	lastId, err := result.LastInsertId()
	if err != nil {
		log.Println(err)
		return 0, err
	}
	return lastId, nil
}

func (var_physician *Physician) Create() (int64, error) {
	ok, err := govalidator.ValidateStruct(var_physician)
	if !ok {
		errMsg := "Validate Physician struct error: Unknown error"
		if err != nil {
			errMsg = "Validate Physician struct error: " + err.Error()
		}
		log.Println(errMsg)
		return 0, errors.New(errMsg)
	}
	t := time.Now()
	var_physician.CreatedAt = t
	var_physician.UpdatedAt = t
	sql := `INSERT INTO physicians (name,created_at,updated_at,introduction) VALUES (:name,:created_at,:updated_at,:introduction)`
	result, err := db.NamedExec(sql, var_physician)
	if err != nil {
		log.Println(err)
		return 0, err
	}
	lastId, err := result.LastInsertId()
	if err != nil {
		log.Println(err)
		return 0, err
	}
	return lastId, nil
}

// AppointmentsCreate used to create the associated objects
func (var_physician *Physician) AppointmentsCreate(am map[string]interface{}) error {
	am["physician_id"] = var_physician.Id
	_, err := CreateAppointment(am)
	return err
}

// GetAppointments used to get associated objects
func (var_physician *Physician) GetAppointments() error {
	var_appointments, err := PhysicianGetAppointments(var_physician.Id)
	if err == nil {
		var_physician.Appointments = var_appointments
	}
	return err
}

// PhysicianGetAppointments a helper fuction used to get associated objects for PhysicianIncludesWhere()
func PhysicianGetAppointments(id int64) ([]Appointment, error) {
	var_appointments, err := FindAppointmentsBy("physician_id", id)
	return var_appointments, err
}

// PatientsCreate used to create the associated objects
func (var_physician *Physician) PatientsCreate(am map[string]interface{}) error {
	// FIXME: use transaction to create these associated objects
	patient_id, err := CreatePatient(am)
	if err != nil {
		return err
	}
	_, err = CreateAppointment(map[string]interface{}{"physician_id": var_physician.Id, "patient_id": patient_id})
	return err
}

// GetPatients used to get associated objects
func (var_physician *Physician) GetPatients() error {
	var_patients, err := PhysicianGetPatients(var_physician.Id)
	if err == nil {
		var_physician.Patients = var_patients
	}
	return err
}

// PhysicianGetPatients a helper fuction used to get associated objects for PhysicianIncludesWhere()
func PhysicianGetPatients(id int64) ([]Patient, error) {
	// FIXME: use transaction to create these associated objects
	sql := "SELECT `patients`.* FROM `patients` INNER JOIN `appointments` ON `patients`.`id` = `appointments`.`patient_id` WHERE `appointments`.`physician_id` = ?"
	var_patients, err := FindPatientsBySql(sql, id)
	return var_patients, err
}

// PicturesCreate used to create the associated objects
func (var_physician *Physician) PicturesCreate(am map[string]interface{}) error {
	am["physician_id"] = var_physician.Id
	_, err := CreatePicture(am)
	return err
}

// GetPictures used to get associated objects
func (var_physician *Physician) GetPictures() error {
	var_pictures, err := PhysicianGetPictures(var_physician.Id)
	if err == nil {
		var_physician.Pictures = var_pictures
	}
	return err
}

// PhysicianGetPictures a helper fuction used to get associated objects for PhysicianIncludesWhere()
func PhysicianGetPictures(id int64) ([]Picture, error) {
	sql := `SELECT pictures WHERE imageable_id = ? AND imageable_type = ?`
	var_pictures, err := FindPicturesBySql(sql, id, "Physician")
	return var_pictures, err
}

func (var_physician *Physician) Destroy() error {
	if var_physician.Id == 0 {
		return errors.New("Invalid Id field: it can't be a zero value")
	}
	err := DestroyPhysician(var_physician.Id)
	return err
}

func DestroyPhysician(id int64) error {
	stmt, err := db.Preparex(db.Rebind(`DELETE FROM physicians WHERE id = ?`))
	_, err = stmt.Exec(id)
	if err != nil {
		return err
	}
	return nil
}

func DestroyPhysicians(ids ...int64) (int64, error) {
	if len(ids) == 0 {
		msg := "At least one or more ids needed"
		log.Println(msg)
		return 0, errors.New(msg)
	}
	idsHolder := strings.Repeat(",?", len(ids)-1)
	sql := fmt.Sprintf(`DELETE FROM physicians WHERE id IN (?%s)`, idsHolder)
	idsT := []interface{}{}
	for _, id := range ids {
		idsT = append(idsT, interface{}(id))
	}
	stmt, err := db.Preparex(db.Rebind(sql))
	result, err := stmt.Exec(idsT...)
	if err != nil {
		return 0, err
	}
	cnt, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	return cnt, nil
}

// DestroyPhysiciansWhere delete records by a where clause
// like: DestroyPhysiciansWhere("name = ?", "John")
// And this func will not call the association dependent action
func DestroyPhysiciansWhere(where string, args ...interface{}) (int64, error) {
	sql := `DELETE FROM physicians WHERE `
	if len(where) > 0 {
		sql = sql + where
	} else {
		return 0, errors.New("No WHERE conditions provided")
	}
	stmt, err := db.Preparex(db.Rebind(sql))
	result, err := stmt.Exec(args...)
	if err != nil {
		return 0, err
	}
	cnt, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	return cnt, nil
}

func (var_physician *Physician) Save() error {
	ok, err := govalidator.ValidateStruct(var_physician)
	if !ok {
		errMsg := "Validate Physician struct error: Unknown error"
		if err != nil {
			errMsg = "Validate Physician struct error: " + err.Error()
		}
		log.Println(errMsg)
		return errors.New(errMsg)
	}
	if var_physician.Id == 0 {
		return errors.New("Invalid Id field: it can't be a zero value")
	}
	var_physician.UpdatedAt = time.Now()
	sqlFmt := `UPDATE physicians SET %s WHERE id = %v`
	sqlStr := fmt.Sprintf(sqlFmt, "name = :name, updated_at = :updated_at, introduction = :introduction", var_physician.Id)
	_, err = db.NamedExec(sqlStr, var_physician)
	return err
}

func UpdatePhysician(id int64, am map[string]interface{}) error {
	if len(am) == 0 {
		return errors.New("Zero key in the attributes map!")
	}
	am["updated_at"] = time.Now()
	keys := make([]string, len(am))
	i := 0
	for k := range am {
		keys[i] = k
		i++
	}
	sqlFmt := `UPDATE physicians SET %s WHERE id = %v`
	setKeysArr := []string{}
	for _, v := range keys {
		s := fmt.Sprintf(" %s = :%s", v, v)
		setKeysArr = append(setKeysArr, s)
	}
	sqlStr := fmt.Sprintf(sqlFmt, strings.Join(setKeysArr, ", "), id)
	_, err := db.NamedExec(sqlStr, am)
	if err != nil {
		log.Println(err)
		return err
	}
	return nil
}

func (var_physician *Physician) Update(am map[string]interface{}) error {
	if var_physician.Id == 0 {
		return errors.New("Invalid Id field: it can't be a zero value")
	}
	err := UpdatePhysician(var_physician.Id, am)
	return err
}

func (var_physician *Physician) UpdateAttributes(am map[string]interface{}) error {
	if var_physician.Id == 0 {
		return errors.New("Invalid Id field: it can't be a zero value")
	}
	err := UpdatePhysician(var_physician.Id, am)
	return err
}

func (var_physician *Physician) UpdateColumns(am map[string]interface{}) error {
	if var_physician.Id == 0 {
		return errors.New("Invalid Id field: it can't be a zero value")
	}
	err := UpdatePhysician(var_physician.Id, am)
	return err
}

func UpdatePhysiciansBySql(sql string, args ...interface{}) (int64, error) {
	if sql == "" {
		return 0, errors.New("A blank SQL clause")
	}
	sql = strings.Replace(strings.ToLower(sql), "set", "set updated_at = ?, ", 1)
	args = append([]interface{}{time.Now()}, args...)
	stmt, err := db.Preparex(db.Rebind(sql))
	result, err := stmt.Exec(args...)
	if err != nil {
		return 0, err
	}
	cnt, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}
	return cnt, nil
}
